using System;

namespace Lesson_73_as_is
{
    /*
     * Приведение типов и наследование
     *      Все типы данных в языке унаследованы от типа object 
     *      object то же самое что и Object
     * 
     * Использование операторов as и is 
     *      Оператор as - преобразует типы, и если преобразование неудачное, то он возвращает null
     *      
     *      Изначально is - проверял переменную на определённый тип данных. 
     *      Сейчас is - проверяет на тип данных и может присвоить значение прямо в обьект
     */

    class Point
    {
        public int X { get; set; }
        public int Y { get; set; }

        public void Print()
        {
            Console.WriteLine("class Point");
            Console.WriteLine("X:\t" + X);
            Console.WriteLine("Y:\t" + Y);
        }

    }
    class Program
    {
        static void Main(string[] args)
        {
            object obj = new Point { X = 5, Y = 20 };   // Когда в тип данных родительского класса присваевается потомок - это неявное преобразование типов
                                                        // Неявное - потому что не указываем, что хотим явно преобразовать один тип в другой
                                                        // Ссылка базового класса может хранить обьекты наследников, но ничего не будет знать о методах,
                                                        // свойствах и т.д., определённых в наследнике. Для этого надо сделать явное приведение типов

            Point point = (Point)obj;                   // Явно обратно преобразуем обьект obj в point и имеем доступ ко всей внутрянке
            
            Foo(obj);

            object obj2 = "string";
            Foo(obj2);

                                                       
        }
        static void Foo(object obj)
        {
            //Point p = (Point)obj;                     // Такое преобразование вызовет исключение
            Point point = obj as Point;                 // С помощью оператора as преобразуем тип obj в тип Point и помещаем в отдельну переменную
                                                        // Если у нас obj реально преобразовать в Point - то приобразуется, а если нет - то переменной point присвоит null
            if (point != null)
            {
                point.Print();
            }
            else
            {
                Console.WriteLine("\nНевозможно преобразовать тип !!!");
            }
        }
        static void Bar(object obj)                         
        {
            if (obj is Point point)                      // Оператор is проверяет тип данных obj на соответствие Point и если да, то может присвоить прямо в новый обьект
            {                                            // Если нет - то просто не выполниться проверка внутри if()
                point.Print();
            }
        }
    }
}
